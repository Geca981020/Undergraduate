5chapter 상위 설계
5. 1 설계의 이해
- 설계: 요구 분석 명세서를 기반으로 어떻게 구축할 것인가를 결정하는 것.
- 요구분석은 what에 설계는 how에 관심이 있다.

<설계서>
- 요구사항을 해결하기 위해 최소한 1가지의 해결방안이 있어야 하며, 가능하면 여러 개를 찾아야 한다.
- 요구분석 명세서의 모든 내용을 설계서에 포함해야 한다.

<설계의 종류 - 관리적 관점>
1) 상위 설계(기본 설계): 소프트웨어의 구조를 설계
- 아키텍쳐 설계, 데이터 설계, 인터페이스 정의, 사용자 인터페이스 설계
- 결과물: 시스템 구조도, 외부 파일 및 DB 설계도
2) 하위 설계(상세 설계): 모듈 및 오퍼레이션의 알고리즘을 설계
- 모듈 설계, 자료구조 설계, 알고리즘 설계
- 결과물: 프로그램 사양서

<설계의 종류 - 기술적 관점>
1) 데이터 설계: 정보 모델링을 이용해서 자료구조와 데이터베이스를 설계
2) 구조 설계: 기능 모델링과 동적 모델링을 이용해 모듈 사이의 관계를 기술
3) 프로시져 설계: 모듈의 내부가 구체적으로 밝혀지며, 알고리즘 결정
4) 사용자 인터페이스 설계: 사용자가 시스템의 기능에 접근할 수 있도록 설계

<설계 가이드라인>
모듈화/계층 구조/인터페이스 최소화/요구분석명세서를 활용

5. 2 설계의 원리
1) 분할과 정복: 큰 문제를 작은 문제로 나누고 작은 문제를 하나하나 해결해가면 전체 문제를 해결하는 방법
2) 추상화: 복잡한 대상의 중요한 부분에 집중하고 상세한 부분은 무시하는 방법
- 과정 추상화, 데이터 추상화, 제어 추상화
3) 단계적 분해: 문제를 점차 세부적으로 구체화해 나가는 방법
4) 모듈화
5) 정보은닉

5. 3 소프트웨어 아키텍쳐
- 아키텍쳐란 시스템을 구성하는 구성요소를 정의하고, 구성요소 간의 관계를 명확히 표현한 것을 말한다.


<품질 속성>
1) 시스템 품질 속성: 가용성, 사용성, 보안성, 성능
2) 비즈니스 품질 속성: 시장 적시성, 비용과 이익, 목표 시장
3) 아키텍쳐 품질 속성: 일관성, 정확성, 완전성
4) 이해관계자별 품질 속성: 발주자, 사용자, 개발자
 
<아키텍쳐 구축 절차>
요구사항 분석 -> 아키텍쳐 분석 -> 아키텍쳐 설계(관점 및 스타일 결정) -> 검증 및 승인

<아키텍쳐 관점>
1) usecase view: 사용자 측면에서 사용자의 기능을 중심으로
2) logical view: 클래스나 컴포넌트 사이의 관계를 중심으로
3) implementation view: 모듈의 동작과 관계를 중심으로
4) process view: 시스템의 성능과 동기화등을 중심으로
5) deployment view: 물리 배치와 컴포넌트들의 배치를 중심으로

<아키텍쳐 스타일> - 정형화된 모델, 개발시간 단축, 유지보수 용이, 성공 확률 업
1) Repository model: 중심 데이터를 관리하는 곳이 있고, 서브 시스템들이 이 데이터에 접근하는 형태
장점: 데이터를 일관성있게 관리 가능, 서브 시스템 추가 편리
단점: repository와 sub system간의 강한 결합. 보안 문제
2) client-server model: client가 요청, sever가 요청을 처리, 네트워크로 구축함
3) Layering model: 기능을 몇 개의 계층으로 나누어 배치.
4) Model-View-Controller Model: View는 사용자에게 보여주는 부분을 Model 데이터의 처리와 저장을 Controller는 이 둘의 사이에서 인터페이스 역할을 수행
장점: 구조 변경이 유리
단점: 속도가 느려지고, 시스템이 복잡해진다.
5) Pipe-Filter Model: Filter가 data stream을 특정 형태로 가공하고 Pipe가 datastream을 다른 Filter로 보낸다. 

5. 4 디자인 패턴
- 자주 사용하는 설계 형태를 정규화한 템플릿
- 생성 패턴: 객체의 생성과 관련된 패턴 5가지
1) Singleton: 한 클래스에서 만들 수 있는 인스턴스는 1개라고 보장해주는 것.
2) Factory Method: 상위클래스에서 객체를 생성하는 인터페이스를, 하위클래스에서 객체 구현을 정의
3) Prototype: 큰 객체를 만들기 위해 복사하고 일 부분만 수정하는 것
4) Builder: 복잡한 인스턴스를 조립하여 만듦.
5) Abstract Factory: 추상적인 부품을 조립해서 추상적인 제품을 만듦.


- 구조 패턴: 클래스나 객체들을 조합하여 더 큰 구조로 만들 수 있게 해주는 패턴 7가지
1) Adapter: 기존 클래스를 재사용할 수 있도록 중간에서 맞춰주는 인터페이스
2) Bridge: 기능부와 추상부를 구별해서 구현하고 이를 연결
3) Composite: 사용자가 단일 객체와 복합 객체를 모두 동일하게 다루도록 한 것
4) Decorator: 기존에 구현되어 있는 클래스에 필요한 기능을 추가해 나가는 것
5) Flyweight: 메모리 사용량을 줄이기 위해, 가능하면 객체생성을 하지말고 공유하자는 것
6) Facade: 인터페이스를 더 상위에서 제공해 사용자가 손쉽게 접근하게 하자는 것
7) Proxy: 대신해서 처리하는 것

- 행위 패턴: 클래스나 객체들이 상호작용 하는 방법을 정의한 패턴 11가지
1) Observer: 한 클래스의 동작을 감시하고, 동작이 일어나면 다른 클래스에게 통보.
2) Strategy: 비슷한 알고리즘 여러개를 구축하고 필요한 알고리즘을 상황에 맞게 선택.
3) Template Method: 상위 클래스는 추상적으로, 구체적인 내용은 하위클래스에서 구현.
