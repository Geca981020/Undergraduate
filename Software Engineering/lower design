6chapter 하위 설계
6. 1 모듈 설계
모듈:하나 또는 몇 개의 논리적인 기능을 수행하기 위한 명령어들의 집합.
모듈화: 소프트웨어를 모듈로 나누는 것
모듈화의 특징: 각각의 모듈은 독립적으로 컴파일 됨/ 한 모듈이 다른 모듈 호출 가능
모듈화의 장점: 코드 재사용 용이/유지보수 용이/기능 추가 용이
- 응집도는 높게, 결합도는 낮게

<응집도(cohesion)>: 모듈 내부의 구성 성분간의 응집된 정도
- 기능적(Function): 단일 기능의 요소로 하나의 모듈을 구성
- 순차적(Sequential): A 요소의 출력이 B요소의 입력으로 들어가는 두 요소로 구성
- 교환적(Communication): 동일한 입력에 대해 서로 다르게 처리하는 요소들로 구성
- 절차적(Procedural): 순서가 정해진 몇 개의 구성 요소로 구성
- 시간적(Temporal): 같은 시간대에 실행되는 요소들로 구성
- 논리적(Logical): 요소들 간에 공통점이 있음
- 우연적(coincidental): 특별한 이유 없음.

<결합도(coupling)>: 모듈과 모듈사이의 결합 정도.
- 자료(Data): 매개변수를 통해 필요한 데이터 만을 주고 받음.
- Stamp: 데이터 만을 주고 받지만 쓸모없는 내용도 주고 받음.
- Control: 한 객체가 다른 객체의 흐름을 알고, control 신호를 보냄.
- External: 어떤 모듈에서 선언한 데이터를 외부에서 다른 모듈이 참조 가능 할 때.
- Common: 서로 다른 모듈이 공통 영역에 있는 변수를 참조 할 때.
- Content: 인터페이스 없이 두 모듈이 서로 상대방의 데이터를 직접 변경할 때. goto


6. 2 소프트웨어 개발 방법과 설계
- process oriented approach: DFD/process 중심/사용되는 데이터를 주위에 표현
- data oriented approach: ERD/데이터가 중심/요구사항분석 -> 개념적 스키마(ERD) -> 논리적 스키마(릴레이션 스키마) -> 물리적 스키마 -> 구현
위 둘의 단점: 재사용의 어려움, 변경이 미치는 효과가 큼

- object oriented approach: 객체가 중심/데이터와 기능을 한 데 묶고 이 객체를 중심으로 모듈을 구성
장점: 재사용이 매우 쉬움, 변경이 상대적으로 간편

6. 3 객체지향의 주요 개념과 특징
<개념>
- 객체(object)
- 인스턴스: 클래스로에 해당되는 객체들 / 인스턴스화: 클래스로부터 객체를 생성하는 것
- 클래스: 공통되는 것들을 묶어서 이름을 붙인 것
<특징>
- 캡슐화(encapsulation): 기능의 사용법만을 알려주고 내부 데이터는 가리는 것.
장점: 데이터 보호, 사용이 간편해짐, 수정 용이
- 정보은닉(information hiding): 외부에서 내부의 데이터를 보지 못하도록 하는 것.
- 상속(inheritance): 상위 클래스의 기능과 데이터를 하위 클래스에 가져와서 그대로 사용
장점: 재사용성 높아짐, 확장 용이
- 다형성(polymorphism): 하나의 명령에 대해 서로 다르게 처리하는 개념. 
ex) 오버로딩, 오버라이딩

6. 4 클래스간의 관계와 설계 원칙
<클래스 관계>
- 연관 관계(association relationship): 한 클래스가 한 클래스를 알고 메시지를 전달
- 일반화 특수화 관계(IS-A): 두 클래스가 상속관계에 있을 때
- 집합 관계(aggregation): 객체 여러개를 모아 큰 객체를 생성할 때
- 포함 관계(composition): 객체 여러개를 모아 큰 객체를 생성하지만 각 객체가 모두 필요.

<클래스 설계 원칙>
- 단일 책임 원칙(SRP): 하나의 클래스는 하나의 기능(책임)을 수행하게 하자
- 개방 폐쇄의 원칙(OCP): 확장(상속)에는 열려있고, 변경에는 닫혀 있어야 한다.
  특정 하위클래스가 상위클래스의 내용을 바꾸지 못하도록 해야한다.
  변경 시 영향력을 최소화 하기 위해 추상클래스-인터페이스를 사용하자.
- 리스코프 교체의 원칙(LSP): 기반 클래스는 파생 클래스로 대체할 수 있어야 한다.
  신버전은 구버전 데이터를 돌릴 수 있어야 한다.
- 의존관계역전의 법칙: 클라이언트는 구체 클래스가 아닌 추상 클래스에 의존해야 한다.
  구체 클래스는 추상 클래스에 비해 쉽게 변하기 때문
- 인터페이스 분리의 법칙: 하나의 일반적인 인터페이스보다 구체적인 여러개의 인터페이스로
