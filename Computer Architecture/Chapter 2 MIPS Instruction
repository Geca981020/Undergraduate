2.1 MIPS Base
- add a, b, c -> MIPS 명령어는 한 종류의 연산만을 지시하며, 항상 변수 3개만을 가진다.
- 레지스터 : 프로세서에 위치한 고속메모리
  →MIPS에서 레지스터의 가수는 32개, 크기는 32bit이다.

- 레지스터가 32개인 이유
레지스터가 아주 많아지면 전기신호가 더 멀리까지 전달되어야 하므로 클럭 사이클 기간이 길어진다.
그리고 레지스터를 31개로 한다고 해도 32개보다 빨라지지 않는다.

- 레지스터는 소량의 데이터만을 저장 할 수 있다.
그러므로 배열이나 구조체같은 자료구조는 메모리에 저장한다.
lw: 메모리에서 레지스터로 데이터를 복사해오는 전송 명령.
sw: 레지스터에서 메모리로 데이터를 보내는 전송 명령. 

- 컴파일러가 하는 추가적인 일 :
변수를 레지스터와 연관 짓는 일, 
배열이나 구조체 같은 자료구조를 메모리에 할당 하는 것.

- MIPS는 최상위주소를 사용하는 빅 엔디안 계열에 속한다.
- 레지스터 스필링: 자주 사용하지 않는 변수를 메모리에 넣는 일 
레지스터보다 변수의 개수가 많다면

2. 2 명령어의 컴퓨터 내부 표현
- Instuction Format: R, I, J, 명령어의 각 부분을 field라고 한다.
- R: op rs rt rd shamt funct / 6 5 5 5 5 6
- I: op rs rt address or constant / 6 5 5 16
- J: op address / 6 26

2. 3 논리연산 명령어
- shift left: sll / shift right: srl
- and, or, nor
- not 사용x -> nor을 사용하고 피연산자 하나가 0이면 not과 같아진다.

2. 4 판단
- Conditional Branch:beq, bne
beq R1. R2. L1 : R1과 R2의 값이 같으면 11으로 가라.
bne R1. R2. L1 R1과 R2의 값이 같지 않으면 LI으로 가라 .
- unconditional Branch: j
- slt, slti

2. 5 하드웨어와 프로시저
- procedure : 제공되는 인수 ( parameter) 에 따라서 특정작업을 수행하는 서브루틴
- jal ProcedureAddress ⇒ 지정된 주소를 점프하면서 동시에 다음 명령어의주소를 $ra 에 저장하는 명령어
- jr $ra ⇒ 레지스터에 저장된 주소로 무조건 점프하라.
- 프로그램 카운터 (PC) : 다음에 실행할 명령어의 주소를 저장해두는 레지스터.
- stack : 레지스터 스필링에 가장 이산적인 자료구조 ⇒ Push Pop
- stack Pointer : 가장 최근에 스택에 할당된 주소를 가리키는 값
→ 스택은 높은 주소에서 낮은 주소 쪽으로 성장 한다.
그러므로 스택에 Push 할 때는 스택 포인터 값을 감소시키고, 스택에서 팝을 할 때는
스택 포인터 값을 증가시켜야 한다.
- $t0~$t9 : 프로시저 호출 시, 피 호출 프로그램이 값을 보존해주지 않는 임시 레지스터
- $s0~$7 : 프로시저 호출 전과 후의 값이 같게 유지되어야 하는 변수.
⇒ 프로시저를 여러번 호출하거나,재귀 프로시저인 경우. 레지스터가 부족하므로 모든 값들은 메모리의 스택에 넣는다.

- $gp (Global Pointer) : 정적 영역을 가리키도록 예약된 레지스터
- procedure frame : 프로시저의 저장된 레지스터와 지역 변수를 가지고 있는 스택뺵
- $fp (frame pointer) : 프로시저 프레임의 첫 번째 Word를 가리킴

- malloc: 힙에 공간을 할당하고, 이 공간을 가리키는 포인터를 결과 값으로 준다.
- free: 힙 공간을 반환.

2. 6 프로그램 번역과 실행
1. Compiler: 고급언어를 어셈블리어로
2. Assembler: 어셈블리어를 object file인 기계어로
3. Linker: 기계어와 라이브러리를 연결해서 실행가능 파일로
4. Loader: Memory에 적재
